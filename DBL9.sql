-- lab9 / 1234


CREATE TABLE CUSTOMER 
( 
CID             VARCHAR2(3) PRIMARY KEY, 
CNAME           VARCHAR2(25), 
CREDIT_LIMIT    NUMBER, 
CREDIT_BALANCE  NUMBER
); 

INSERT INTO CUSTOMER VALUES ('C81','Alpha',99,0); 
INSERT INTO CUSTOMER VALUES ('C82','Bravo',700,0); 
INSERT INTO CUSTOMER VALUES ('C83','Charlie',5000,0); 
COMMIT; 

CREATE TABLE SALES 
( 
SID  NUMBER PRIMARY KEY, 
SDATE  DATE default SYSDATE, 
PCODE  VARCHAR2(3), 
CID    VARCHAR2(3), 
QTY    NUMBER,
RATE   NUMBER, 
AMOUNT NUMBER, 
FOREIGN KEY (CID) REFERENCES CUSTOMER(CID) 
); 


-- Q1a

CREATE OR REPLACE TRIGGER SALES_Before_insert
    BEFORE INSERT 
    ON SALES 
    FOR EACH ROW 
DECLARE 
    v_new_credit_balance NUMBER;
BEGIN
    UPDATE CUSTOMER
    SET CREDIT_BALANCE = CREDIT_BALANCE + :new.AMOUNT
    WHERE CID = :new.CID;
END;

SELECT * FROM CUSTOMER WHERE CID = 'C82';
INSERT INTO SALES VALUES (111, SYSDATE, 'PPP', 'C82', 3, 50, 2); 


-- Q1b

CREATE OR REPLACE TRIGGER SALES_Before_Del
    BEFORE DELETE
    ON SALES
    FOR EACH ROW
DECLARE 
    v_del_credit_balance NUMBER;
BEGIN
    UPDATE CUSTOMER
    SET CREDIT_BALANCE = CREDIT_BALANCE - :old.AMOUNT 
    WHERE CID = :old.CID;
END;

SELECT * FROM CUSTOMER WHERE CID = 'C82';
DELETE FROM SALES WHERE SID = 111;


-- Q1c

DROP TRIGGER SALES_Before_insert;
DROP TRIGGER SALES_Before_Del;

CREATE OR REPLACE TRIGGER SALES_Insert_Del
    BEFORE INSERT OR DELETE
    ON SALES
    FOR EACH ROW
DECLARE 
    v_credit_balance NUMBER;
BEGIN
    IF INSERTING THEN
        UPDATE CUSTOMER
        SET CREDIT_BALANCE = CREDIT_BALANCE + :new.AMOUNT
        WHERE CID = :new.CID;
    END IF;
    
    IF DELETING THEN
        UPDATE CUSTOMER
        SET CREDIT_BALANCE = CREDIT_BALANCE - :old.AMOUNT 
        WHERE CID = :old.CID;
    END IF;
END;

SELECT * FROM CUSTOMER WHERE CID = 'C82';
INSERT INTO SALES VALUES (111, SYSDATE, 'PPP', 'C82', 3, 50, 2);
DELETE FROM SALES WHERE SID = 111;


-- Q2a

DROP TABLE ORDERS;

CREATE TABLE orders (  
    order_id number(5) PRIMARY KEY, 
    quantity number(4),  
    cost_per_item number(6,2),  
    total_cost number(8,2),  
    discount number(2),  
    final_charged number(8,2) 
);


-- Q2b

CREATE OR REPLACE TRIGGER ORDERS_is
    BEFORE INSERT
    ON ORDERS 
    FOR EACH ROW 
DECLARE
    v_total_cost NUMBER;
    v_discount_pc NUMBER;
BEGIN
    v_discount_pc := :new.DISCOUNT / 100;
    :new.TOTAL_COST := :new.COST_PER_ITEM * :new.QUANTITY;
    :new.FINAL_CHARGED := :new.TOTAL_COST - (:new.TOTAL_COST * v_discount_pc);
END;


-- Q2c

INSERT INTO orders( order_id, quantity, cost_per_item,discount) VALUES (1, 10, 200, 25); 
SELECT * FROM ORDERS WHERE ORDER_ID = 1;
DELETE FROM ORDERS WHERE ORDER_ID = 1;


-- Q2d

INSERT INTO orders( order_id, quantity, cost_per_item,discount) VALUES (2,2, 100,5); 
SELECT * FROM ORDERS WHERE ORDER_ID = 2;
DELETE FROM ORDERS WHERE ORDER_ID = 2;
SELECT * FROM ORDERS; 


-- Q3

CREATE TABLE FLUCTUATIONS (
    recDate DATE DEFAULT SYSDATE, 
    Currency VARCHAR2(3),
    Difference NUMBER
);

CREATE TABLE Currency_con (
    CID INT PRIMARY KEY,
    Currency VARCHAR2(3),
    Rate NUMBER
);

--TESTING
--DROP TABLE FLUCTUATIONS;
--DROP TABLE CURRENCY_CON;

-- Q3b

INSERT INTO Currency_con (CID, Currency, Rate) 
VALUES (1, 'USD', 278.50);

INSERT INTO Currency_con (CID, Currency, Rate) 
VALUES (2, 'GBP', 345.30);

INSERT INTO Currency_con (CID, Currency, Rate) 
VALUES (3, 'EUR', 300.20);

INSERT INTO Currency_con (CID, Currency, Rate) 
VALUES (4, 'JPY', 2.08);

INSERT INTO Currency_con (CID, Currency, Rate) 
VALUES (5, 'AED', 75.80);

INSERT INTO fluctuations (recDate, Currency, Difference) 
VALUES (TO_DATE('2023-10-01', 'YYYY-MM-DD'), 'USD', 1.25);

INSERT INTO fluctuations (recDate, Currency, Difference) 
VALUES (TO_DATE('2023-10-02', 'YYYY-MM-DD'), 'USD', -0.50);

INSERT INTO fluctuations (recDate, Currency, Difference) 
VALUES (TO_DATE('2023-10-03', 'YYYY-MM-DD'), 'GBP', 2.30);

INSERT INTO fluctuations (recDate, Currency, Difference) 
VALUES (TO_DATE('2023-10-04', 'YYYY-MM-DD'), 'GBP', -1.15);

INSERT INTO fluctuations (recDate, Currency, Difference) 
VALUES (TO_DATE('2023-10-05', 'YYYY-MM-DD'), 'EUR', 0.75);


-- Q3c i

CREATE OR REPLACE TRIGGER FLUCT_Before_Insert_LOG 
    BEFORE INSERT
    ON CURRENCY_CON
    FOR EACH ROW
BEGIN
    INSERT INTO FLUCTUATIONS (recDate, Currency, Difference)
    VALUES (SYSDATE, :new.Currency, 0);
END;

SELECT * FROM FLUCTUATIONS;
SELECT * FROM CURRENCY_CON;

INSERT INTO Currency_con (CID, Currency, Rate)
VALUES (6, 'CAD', 203.50);

--TESTING
--DROP TRIGGER FLUCT_Before_Insert_LOG;


-- Q3c ii

CREATE OR REPLACE TRIGGER Currency_LOG
    AFTER UPDATE
    ON CURRENCY_CON
    FOR EACH ROW
BEGIN     
    INSERT INTO FLUCTUATIONS (recDate, Currency, Difference)
    VALUES (SYSDATE, :new.Currency, :new.RATE - :old.RATE);
END;

UPDATE CURRENCY_CON
SET RATE = 300
WHERE CURRENCY = 'USD';

SELECT * FROM CURRENCY_CON;
SELECT * FROM FLUCTUATIONS;


-- Q4a

CREATE TABLE WORKER (
    WorkerID INT PRIMARY KEY, 
    LName VARCHAR2(255),
    GENDER CHAR(1),
    SALARY INT,
    COMMISSION NUMBER(4, 2),
    DeptID INT
);


-- Q4b

CREATE SEQUENCE WorkerID_Seq
START WITH 100
INCREMENT BY 5;


-- Q4c

CREATE OR REPLACE TRIGGER Get_Worker_ID
    BEFORE INSERT ON WORKER
    FOR EACH ROW
BEGIN
    :new.WorkerID := WorkerID_Seq.NEXTVAL;
END;


-- Q4d
INSERT INTO WORKER (LName, GENDER, SALARY, COMMISSION, DeptID)
VALUES ('Smith', 'M', 5000, 12.50, 1);

INSERT INTO WORKER (LName, GENDER, SALARY, COMMISSION, DeptID)
VALUES ('Johnson', 'F', 4000, 15.00, 2);

--TESTING
SELECT * FROM WORKER;


-- Q5a

CREATE TABLE OrderHeader (
    OrderID INT PRIMARY KEY,
    Odate DATE,
    CustID INT,
    Total NUMBER(10, 2) DEFAULT 0
);

CREATE TABLE Order_Item (
    OrderID INT,
    ItemID INT,
    Qty INT,
    Subtotal NUMBER(10, 2),
    CONSTRAINT pk_order_item PRIMARY KEY (OrderID, ItemID),
    CONSTRAINT fk_order FOREIGN KEY (OrderID) REFERENCES OrderHeader(OrderID)
);

--TESTING
DROP TABLE ORDERHEADER;
DROP TABLE ORDER_ITEM;

-- Q5b

CREATE OR REPLACE TRIGGER UPDATE_ORDER_TOTAL
    AFTER INSERT OR UPDATE OR DELETE ON Order_Item
DECLARE
    v_total NUMBER(10, 2);
BEGIN
    FOR order_rec IN (SELECT DISTINCT OrderID FROM Order_Item) LOOP
        SELECT COALESCE(SUM(Subtotal), 0) INTO v_total
        FROM Order_Item
        WHERE OrderID = order_rec.OrderID;

        UPDATE orders
        SET total_cost = v_total
        WHERE order_id = order_rec.OrderID;
    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error updating Total in OrderHeader.');
END;


-- Q5c

INSERT INTO OrderHeader (OrderID, Odate, CustID) VALUES (1, SYSDATE, 1);
INSERT INTO Order_Item (OrderID, ItemID, Qty, Subtotal) VALUES (1, 1, 20, 200);
INSERT INTO Order_Item (OrderID, ItemID, Qty, Subtotal) VALUES (1, 2, 5, 100);

--TESTING
SELECT * FROM ORDERHEADER;
SELECT * FROM ORDER_ITEM;

-- Q6

SET SERVEROUTPUT ON;
CREATE OR REPLACE FUNCTION AVERAGE_DEPT_SALARY (DEPT_NAME IN VARCHAR2) 
RETURN NUMBER IS
    AVG_SALARY NUMBER;
BEGIN
    SELECT AVG(E.SALARY)
    INTO AVG_SALARY
    FROM EMPLOYEES E
    JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    WHERE D.DEPARTMENT_NAME = DEPT_NAME;

    RETURN AVG_SALARY;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('NO DATA FOUND');
        RETURN NULL;
END;


--TESTING
SELECT average_dept_salary('IT') 
FROM dual;


-- Q7

SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE MAX_REGION_SALARY IS
BEGIN
    FOR REC IN (
        SELECT R.REGION_NAME, MAX(E.SALARY) AS MAX_SALARY
        FROM EMPLOYEES E
        JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
        JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
        JOIN COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
        JOIN REGIONS R ON C.REGION_ID = R.REGION_ID
        GROUP BY R.REGION_NAME
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Region: ' || REC.REGION_NAME || ' - Max Salary: ' || REC.MAX_SALARY);
    END LOOP;
END;

SET SERVEROUTPUT ON;
EXEC MAX_REGION_SALARY;



-- Q8

SET SERVEROUTPUT ON;
CREATE OR REPLACE FUNCTION EMP_COUNT_MULTI_JOBS
RETURN NUMBER IS
    EMP_COUNT NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO EMP_COUNT
    FROM (
        SELECT EMPLOYEE_ID
        FROM JOB_HISTORY
        GROUP BY EMPLOYEE_ID
        HAVING COUNT(*) > 1
    );

    RETURN EMP_COUNT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('NOBODY HAS >1 JOB');
        RETURN 0;
END;

--TESTING
SELECT EMP_COUNT_MULTI_JOBS() 
FROM dual;